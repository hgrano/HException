-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heterogeneously typed error handling.
@package HException
@version 0.1.0.2


-- | Heterogeneously typed exceptions.
module Control.HException

-- | A heterogeneously typed <a>Exception</a>, which holds an underlying
--   exception that is statically constrained to be one of the type-level
--   list <tt>es</tt>.
data HException es

-- | Type alias for ease of constructing exception type-level lists.
type (:^:) e es = Tagged e e : es

-- | A singleton exception type-level list.
type Only e = e :^: '[]

-- | The type of <a>HException</a>s containing only one type of exception.
type HException1 e = HException (Only e)

-- | The type of heterogeneous exceptions consisting of both <tt>es</tt>
--   and <tt>es'</tt>.
type Both es es' = HAppendListR es es'

-- | The type-level list <tt>xs</tt> is constrained to contain only
--   distinct types, and so can be indexed via type alone.
type TypeIndexed xs = HTypeIndexed xs

-- | The type <tt>x</tt> is contained in the type-level list <tt>xs</tt>.
type Member x xs = MkVariant x x xs

-- | Construct a <a>HException</a> from a standard exception value.
hException :: (Member e es, TypeIndexed es) => e -> HException es

-- | Extract an exception of a specific type from a <a>HException</a>.
--   Returns <a>Nothing</a> if the exception encased is not of the required
--   type.
getMay :: Member e es => HException es -> Maybe e

-- | Specialization of <a>getMay</a> for cases where there is only a single
--   type of exception.
get :: HException1 e -> e

-- | Split <tt>xs</tt> into two groups <tt>xs'</tt> and <tt>xs''</tt>.
type Slice xs xs' xs'' = (SplitVariant xs xs' xs'', DeleteAll xs' xs xs'')

-- | Extract either the exceptions in the left type-level list <tt>el</tt>
--   if the type of the underlying exception is in <tt>el</tt>, or
--   otherwise return an exception in the right type-level list.
slice :: (Slice es el er, TypeIndexed el, TypeIndexed er) => HException es -> Either (HException el) (HException er)

-- | Constrain that the type-level list <tt>xs'</tt> contains all of the
--   elements of the type-level list <tt>xs</tt>.
type Subset xs xs' = ExtendsVariant xs xs'

-- | Changes the type of a <a>HException</a> so it is more general than the
--   original, without changing the underlying exception.
generalize :: (Subset es es', TypeIndexed es') => HException es -> HException es'


-- | Functions for handling <a>HException</a>s using <a>ExceptT</a>.
module Control.Monad.Trans.HExcept

-- | The heterogeneous exception monad. Computations are either one of a
--   known set of exceptions <tt>es</tt> or a value.
type HExcept es = Except (HException es)

-- | A specialization of <a>HExcept</a> for computations which can return
--   only one type of exception.
type HExcept1 e = HExcept (Only e)

-- | A monad transformer that adds heterogeneous exceptions into other
--   monads.
type HExceptT es = ExceptT (HException es)

-- | A specialization of <a>HExceptT</a> for computations which can return
--   only one type of exception.
type HExceptT1 e = HExceptT (Only e)

-- | Lift a <a>HExcept</a> into its transformer version.
hExceptT :: Applicative m => HExcept es a -> HExceptT es m a

-- | Extend the given result so that it may be used in a context which can
--   return a superset of the errors that may arise from the original
--   result. This is useful for calling multiple functions which return
--   different errors types from within a single function. Note: this can
--   also be used to re-order the error types.
extend :: (Functor m, Subset es es', TypeIndexed es') => HExceptT es m a -> HExceptT es' m a

-- | Signal an exception value <tt>e</tt>.
hThrowE :: (Member e es, Monad m, TypeIndexed es) => e -> HExceptT es m a

-- | The type of functions used to handle the exceptions <tt>es</tt>, which
--   may return the exceptions <tt>es'</tt>.
type Handler es es' a = HandlerT es es' Identity a

-- | The monad transformer version of <a>Handler</a>.
type HandlerT es es' m a = HException es -> HExceptT es' m a

-- | Construct a handler from a function which operates on the underlying
--   exception type.
handler1 :: (e -> HExceptT es m a) -> HandlerT (Only e) es m a

-- | Lift a (pure) handler into <tt>m</tt>.
handlerT :: Applicative m => Handler es es' a -> HandlerT es es' m a

-- | Chain <a>HandlerT</a>s together.
orElse :: (Slice es'' es es', TypeIndexed es, TypeIndexed es') => HandlerT es os m a -> HandlerT es' os m a -> HandlerT es'' os m a

-- | Try to use the provided <a>HandlerT</a> or, if that handler does not
--   apply, return the default.
orDefault :: ProjectVariant es' es => HandlerT es os m a -> HExceptT os m a -> HandlerT es' os m a

-- | A specialization of <a>HExcept</a> for computations in which all
--   possible exception types have been dealt with. This means the domain
--   of possible exceptions is empty.
type Value = HExcept '[]

-- | The monad transformer version of <a>Value</a>.
type ValueT = HExceptT '[]

-- | Extract the value from a computation result after all exceptions have
--   been handled. This is type-safe because the type of exceptions is
--   constrained to be empty.
value :: Value a -> a

-- | Monad transformer version of <a>value</a>.
valueT :: Monad m => ValueT m a -> m a
